//leetcode 139
    public boolean wordBreak(String s, List<String> wordDict) {
        int n = s.length();
        HashSet<String> set = new HashSet<>();
        int ml = 0;
        for(String ss : wordDict){
            set.add(ss);
            ml = Math.max(ml , ss.length());
        }
        
        boolean [] dp = new boolean[n+1];
        dp[0] = true;
        for(int i = 0; i<=n; i++){
            if(dp[i]==true){
                
                for(int l = 1; l<=ml+i && i+l<=n; l++){
                    String subs = s.substring(i,i+l);
                    if(set.contains(subs)){
                        dp[i+l] = true;
                    }
                }
            }
            if(dp[n]==true) return true;
        }
        return false;
    }
//leetcode 140

public List<String> wordBreak(String s, List<String> wordDict) {
        HashSet<String> set = new HashSet();
        int maxLen = 0;
        for(String ss : wordDict){
            set.add(ss);
            maxLen = Math.max(maxLen , ss.length());
        }
        int n = s.length();
        boolean[] dp = new boolean[n+1];
        dp[0] = true;
        for(int i = 0; i<=n; i++){
            if(dp[i]==true){
                
                for(int l = 1; l<=maxLen && i+l<=n; l++){
                   String sbs =  s.substring(i,i+l);
                   if(set.contains(sbs)){
                      dp[i+l] = true; 
                     }
                }
                
            }
        }
        List<String> ans = new ArrayList<>();
        if(dp[n]==false) return ans;
        helper(ans,0,"",s,set,dp,maxLen);
        return ans;
    }
    public void helper(List<String> ans,int i,String asf,String s,HashSet<String> set,boolean[] dp,int maxLen){
        if(i>=s.length()){
           ans.add(asf.substring(0,asf.length()-1));
            return;
        }
        
        for(int l = 1; l<=maxLen && i+l<=s.length(); l++){
            if(dp[i+l]){
                String ss = s.substring(i,i+l);
                if(set.contains(ss)){
                   helper(ans,i+l,asf+ss+" ",s,set,dp,maxLen); 
                }
                
            }
            
        }
        
    }
    
    // zer one knapsack
    
     public static void main(String[] args) throws Exception {
       Scanner scn = new Scanner(System.in);
       int n = scn.nextInt();
        int[] values = new int[n];
        for(int i = 0; i<n; i++) values[i]  = scn.nextInt();  
     
     
        int[] weight = new int[n];
        for(int i = 0; i<n; i++) weight[i]  = scn.nextInt(); 
        
        int capacity = scn.nextInt();
        int [][] dp = new int[n+1][capacity+1];
        for(int i = 1; i<=n; i++){
            for(int cap = 1; cap<=capacity; cap++){
                int val = values[i-1];
                int wt = weight[i-1];
                if(cap>=wt){
                    int inc = val+dp[i-1][cap-wt];
                    int exc = dp[i-1][cap];
                    dp[i][cap] = Math.max(inc,exc);
                    
                }else{
                    // exclude
                    dp[i][cap]=dp[i-1][cap];
                }
                
            }
        }
        System.out.println(dp[n][capacity]);
    }
    
    //leetcode 300
    
    int fans;
    public int lengthOfLIS(int[] nums) {
        // fans = 1;
        // LIS_rec(nums,nums.length-1,new int[nums.length] );
        // return fans;
        return LIS_tab(nums);
    }
     public int LIS_rec(int[] nums , int ei,int[] dp){
        if(ei==0){
            return dp[ei] = 1;
        }
        if(dp[ei] != 0) return dp[ei];
        int len = 1;
        for(int si = 0; si<= ei-1; si++){
            int rec = LIS_rec(nums,si,dp);
            if(nums[si]<nums[ei]){
                len = Math.max(rec+1,len);
            }
        }
        fans = Math.max(fans,len);
        return dp[ei] = len;
    }
    public int LIS_tab(int[] nums){
        
        int ans = 1;
        int[] dp = new int[nums.length];
        Arrays.fill(dp,1);
        for(int ei = 1; ei<nums.length; ei++){
           for(int si = 0; si<ei; si++){
               if(nums[si]<nums[ei]){
                   dp[ei] = Math.max(dp[si]+1,dp[ei]);
               }
           }
            ans = Math.max(ans , dp[ei]);
        }
        return ans;
        
    }
    
    //unbounded knapsack
           
           int[] dp = new int[capacity+1];
           
           for(int cap = 1; cap<=capacity; cap++){
               int max= 0;
               for(int i = 0; i<n; i++){
                   int vl = values[i];
                   int wt = weight[i];
                   if(cap>=wt){  //check item
                      int amt = vl+dp[cap-wt];
                      if(max<amt){
                          max = amt;
                      }
                   }
               }
               
               dp[cap] = max;
           }
           
           System.out.println(dp[capacity]);
           
           
